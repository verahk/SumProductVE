% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cpquery.R
\name{cpquery}
\alias{cpquery}
\alias{dag_from_cpts}
\alias{areAncestors}
\alias{cpts_from_bn}
\title{Exact computation of conditional probability distributions}
\usage{
cpquery(cpts, y, x = integer(0), anc = NULL)

dag_from_cpts(cpts)

areAncestors(
  dag,
  nodes,
  seqn = seq_len(ncol(dag)),
  anc = rep(FALSE, ncol(dag))
)

cpts_from_bn(bn)
}
\arguments{
\item{cpts}{(list) a discrete [bnlearn::bn.fit] object or a
list of [base::array]s that specifies a conditional probability table $P(X_i| Pa(X_i))$
For each array the `dimnames` attribute must be a named list, indicating the
scope of the vector - i.e. the names of X_i and Pa(X_i).}

\item{y}{(integer vector)
position of the (set of) variable(s) in `cpts`}

\item{x}{(integer vector)
position of variables that constitutes the conditioning set.
Defaults to the `integer(0)`}

\item{anc}{(logical vector)
of length `n` indicating ancestors of `y` and/or `x`.
If `NULL` (default), the ancestors is computed via the DAG implied by `cpts`.}

\item{dag}{an adjacency matrix}

\item{nodes}{column position of nodes}
}
\value{
an array with `length(y, x)` dimensions, with the conditional probabilities of `y` given `x`.

- `dag_from_cpts`: a n-by-n adjacency matrix of the DAG consistent with the scope of `cpts`

- `areAncestors`: a n-length logical vector indicating which variables are ancestors of `nodes`
}
\description{
Compute conditional probability distributions from a set of CPTs associated
associated with a Bayesian network, using the variable elimination algorithm.
}
\details{
- On the `anc` argument and elimination order:
 With the intention to reduce computation time, a pre-calculation of the set of
 ancestors of `x` and `y` is included as default and the remainding CPTs are
 left out of the sum-product-VE algorithm is to avoid summation over marginal
 distributions that sums to 1.
 As computing ancestor relations also can be computationally intensive, one might be
 better of setting `anc = rep(n, TRUE)` in small DAGs or if the set of ancestors
 include many variables.
 The elimination order is in the order of the CPTs. If the topological ordering
 is known, reordering the CPTs can also reduce compuation time.
}
\examples{

# specify a set of CPTs
new_factor <- function(val, dim, scope) array(val, dim, setNames(vector("list", length(dim)), scope))
z <- new_factor(c(.5, .5), 2, "z")
x <- new_factor(c(.5, .5),  2, "x")
y <- new_factor(c(.1, .9,
                  .2, .8,
                  .3, .7,
                  .4, .6), c(2, 2, 2), c("y", "x", "z"))
cpts <- list(z = z, x = x, y = y)

# marginal prob
cpquery(cpts, y = "y")

# conditional probs
cpquery(cpts, y = "y", x = "x")
stopifnot(cpquery(cpts, y =  "y", x = c("x", "z")) == y)

# obtain DAG from cpts
dag <- dag_from_cpts(cpts)
dag

# identify ancestors of a set of nodes
anc <- areAncestors(dag, 1:2)  # a node is an ancestor of itself
anc

}
